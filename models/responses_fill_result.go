// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// ResponsesFillResult responses fill result
//
// swagger:model responses.FillResult
type ResponsesFillResult struct {

	// Unique client assigned ID for the order
	// Example: x1234
	ClientID string `json:"client_id,omitempty"`

	// Fill time
	// Example: 1681375176910
	CreatedAt int64 `json:"created_at,omitempty"`

	// Fee paid by the user
	// Example: 7.56
	Fee string `json:"fee,omitempty"`

	// Asset that fee is charged in
	// Example: USDC
	FeeCurrency string `json:"fee_currency,omitempty"`

	// Fill type, can be FILL, LIQUIDATION or TRANSFER
	// Example: FILL
	FillType string `json:"fill_type,omitempty"`

	// Unique string ID of fill per FillType
	// Example: 8615262148007718462
	ID string `json:"id,omitempty"`

	// Maker or Taker
	Liquidity struct {
		ResponsesTraderRole
	} `json:"liquidity,omitempty"`

	// Market name
	// Example: BTC-USD-PERP
	Market string `json:"market,omitempty"`

	// Order ID
	// Example: 1681462103821101699438490000
	OrderID string `json:"order_id,omitempty"`

	// Price at which order was filled
	// Example: 30000.12
	Price string `json:"price,omitempty"`

	// Realized funding of the fill
	// Example: 7.56
	RealizedFunding string `json:"realized_funding,omitempty"`

	// Realized PnL of the fill
	// Example: 7.56
	RealizedPnl string `json:"realized_pnl,omitempty"`

	// Remaining size of the order
	// Example: 0.5
	RemainingSize string `json:"remaining_size,omitempty"`

	// Taker side
	Side struct {
		ResponsesOrderSide
	} `json:"side,omitempty"`

	// Size of the fill
	// Example: 0.5
	Size string `json:"size,omitempty"`
}

// Validate validates this responses fill result
func (m *ResponsesFillResult) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLiquidity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSide(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ResponsesFillResult) validateLiquidity(formats strfmt.Registry) error {
	if swag.IsZero(m.Liquidity) { // not required
		return nil
	}

	return nil
}

func (m *ResponsesFillResult) validateSide(formats strfmt.Registry) error {
	if swag.IsZero(m.Side) { // not required
		return nil
	}

	return nil
}

// ContextValidate validate this responses fill result based on the context it is used
func (m *ResponsesFillResult) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLiquidity(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSide(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ResponsesFillResult) contextValidateLiquidity(ctx context.Context, formats strfmt.Registry) error {

	return nil
}

func (m *ResponsesFillResult) contextValidateSide(ctx context.Context, formats strfmt.Registry) error {

	return nil
}

// MarshalBinary interface implementation
func (m *ResponsesFillResult) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ResponsesFillResult) UnmarshalBinary(b []byte) error {
	var res ResponsesFillResult
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
