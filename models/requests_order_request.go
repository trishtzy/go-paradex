// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// RequestsOrderRequest requests order request
//
// swagger:model requests.OrderRequest
type RequestsOrderRequest struct {

	// Unique client assigned ID for the order
	// Example: 123454321
	// Max Length: 64
	ClientID string `json:"client_id,omitempty"`

	// Order flags, allow flag: REDUCE_ONLY
	Flags []ResponsesOrderFlag `json:"flags"`

	// Order Instruction, GTC, IOC or POST_ONLY if empty GTC
	// Required: true
	Instruction *string `json:"instruction"`

	// Market for which order is created
	// Example: BTC-USD-PERP
	// Required: true
	Market *string `json:"market"`

	// Order price
	// Example: 29500.12
	// Required: true
	Price *string `json:"price"`

	// Order will be created if it is received by API within RecvWindow milliseconds from signature timestamp, minimum is 10 milliseconds
	RecvWindow int64 `json:"recv_window,omitempty"`

	// Order side
	// Required: true
	Side struct {
		ResponsesOrderSide
	} `json:"side"`

	// Order Payload signed with STARK Private Key
	// Required: true
	Signature *string `json:"signature"`

	// Timestamp of order creation, used for signature verification
	// Required: true
	SignatureTimestamp *int64 `json:"signature_timestamp"`

	// Size of the order
	// Example: 1.213
	// Required: true
	Size *string `json:"size"`

	// Self Trade Prevention, EXPIRE_MAKER, EXPIRE_TAKER or EXPIRE_BOTH, if empty EXPIRE_TAKER
	Stp string `json:"stp,omitempty"`

	// Trigger price for stop order
	TriggerPrice string `json:"trigger_price,omitempty"`

	// Order type
	// Required: true
	Type struct {
		ResponsesOrderType
	} `json:"type"`
}

// Validate validates this requests order request
func (m *RequestsOrderRequest) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateClientID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFlags(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInstruction(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMarket(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePrice(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSide(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSignature(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSignatureTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSize(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RequestsOrderRequest) validateClientID(formats strfmt.Registry) error {
	if swag.IsZero(m.ClientID) { // not required
		return nil
	}

	if err := validate.MaxLength("client_id", "body", m.ClientID, 64); err != nil {
		return err
	}

	return nil
}

func (m *RequestsOrderRequest) validateFlags(formats strfmt.Registry) error {
	if swag.IsZero(m.Flags) { // not required
		return nil
	}

	for i := 0; i < len(m.Flags); i++ {

		if err := m.Flags[i].Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("flags" + "." + strconv.Itoa(i))
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("flags" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

func (m *RequestsOrderRequest) validateInstruction(formats strfmt.Registry) error {

	if err := validate.Required("instruction", "body", m.Instruction); err != nil {
		return err
	}

	return nil
}

func (m *RequestsOrderRequest) validateMarket(formats strfmt.Registry) error {

	if err := validate.Required("market", "body", m.Market); err != nil {
		return err
	}

	return nil
}

func (m *RequestsOrderRequest) validatePrice(formats strfmt.Registry) error {

	if err := validate.Required("price", "body", m.Price); err != nil {
		return err
	}

	return nil
}

func (m *RequestsOrderRequest) validateSide(formats strfmt.Registry) error {

	return nil
}

func (m *RequestsOrderRequest) validateSignature(formats strfmt.Registry) error {

	if err := validate.Required("signature", "body", m.Signature); err != nil {
		return err
	}

	return nil
}

func (m *RequestsOrderRequest) validateSignatureTimestamp(formats strfmt.Registry) error {

	if err := validate.Required("signature_timestamp", "body", m.SignatureTimestamp); err != nil {
		return err
	}

	return nil
}

func (m *RequestsOrderRequest) validateSize(formats strfmt.Registry) error {

	if err := validate.Required("size", "body", m.Size); err != nil {
		return err
	}

	return nil
}

func (m *RequestsOrderRequest) validateType(formats strfmt.Registry) error {

	return nil
}

// ContextValidate validate this requests order request based on the context it is used
func (m *RequestsOrderRequest) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateFlags(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSide(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RequestsOrderRequest) contextValidateFlags(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Flags); i++ {

		if swag.IsZero(m.Flags[i]) { // not required
			return nil
		}

		if err := m.Flags[i].ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("flags" + "." + strconv.Itoa(i))
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("flags" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

func (m *RequestsOrderRequest) contextValidateSide(ctx context.Context, formats strfmt.Registry) error {

	return nil
}

func (m *RequestsOrderRequest) contextValidateType(ctx context.Context, formats strfmt.Registry) error {

	return nil
}

// MarshalBinary interface implementation
func (m *RequestsOrderRequest) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *RequestsOrderRequest) UnmarshalBinary(b []byte) error {
	var res RequestsOrderRequest
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
