// Code generated by go-swagger; DO NOT EDIT.

package authentication

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"

	"github.com/go-openapi/runtime"
	httptransport "github.com/go-openapi/runtime/client"
	"github.com/go-openapi/strfmt"
)

// New creates a new authentication API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

// New creates a new authentication API client with basic auth credentials.
// It takes the following parameters:
// - host: http host (github.com).
// - basePath: any base path for the API client ("/v1", "/v3").
// - scheme: http scheme ("http", "https").
// - user: user for basic authentication header.
// - password: password for basic authentication header.
func NewClientWithBasicAuth(host, basePath, scheme, user, password string) ClientService {
	transport := httptransport.New(host, basePath, []string{scheme})
	transport.DefaultAuthentication = httptransport.BasicAuth(user, password)
	return &Client{transport: transport, formats: strfmt.Default}
}

// New creates a new authentication API client with a bearer token for authentication.
// It takes the following parameters:
// - host: http host (github.com).
// - basePath: any base path for the API client ("/v1", "/v3").
// - scheme: http scheme ("http", "https").
// - bearerToken: bearer token for Bearer authentication header.
func NewClientWithBearerToken(host, basePath, scheme, bearerToken string) ClientService {
	transport := httptransport.New(host, basePath, []string{scheme})
	transport.DefaultAuthentication = httptransport.BearerToken(bearerToken)
	return &Client{transport: transport, formats: strfmt.Default}
}

/*
Client for authentication API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientOption may be used to customize the behavior of Client methods.
type ClientOption func(*runtime.ClientOperation)

// ClientService is the interface for Client methods
type ClientService interface {
	Auth(params *AuthParams, opts ...ClientOption) (*AuthOK, error)

	Onboarding(params *OnboardingParams, opts ...ClientOption) (*OnboardingOK, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
	Auth gets j w t

	Authenticate using signed payload to get a JWT for usage in other endpoints

There are multiple valid headers required to be sent as part of this request.

For onboarding examples, refer to `go`, `java` and `python` code in [code-samples](https://github.com/tradeparadex/code-samples).

#### StarkNet Message Hash and Signature

Inspired by [EIP-712](https://eips.ethereum.org/EIPS/eip-712),
(a standard for hashing and signing typed structured data)
the encoding of an off-chain message is defined as:

`signed_data = Enc[PREFIX_MESSAGE, domain_separator, account, hash_struct(message)]`

where:

- `PREFIX_MESSAGE = "StarkNet Message"`
- `domain_separator` is defined as the `hash_struct` of the StarkNetDomain struct:
  - Struct contains: `name`, `chainId` and `version`
  - `chainId` is can be obtained calling `GET /system/config`

- `account` is the StarkNet account address
- The message to be hashed is represented as a struct
  - `hash_struct(message) = Enc[type_hash(MyStruct), Enc[param1], ..., Enc[paramN]]`
  - where `type_hash` is defined as in EIP-712 (but using `selector` instead of `keccak`)
  - More details on StarkNet - [Hash Functions](https://docs.starknet.io/architecture-and-concepts/cryptography/#hash_functions)

In case of more complex structure of object, you have to work in the spirit of EIP-712.
This json structure has 4 mandatory items: `types`, `primaryType`, `domain` and `message`.
These items are designed to be able to be an interface with a wallet.
At sign request, the wallet will display:

- `message` will be displayed at the bottom of the wallet display,
showing clearly (not in hex) the message to sign.
Its structure has to be in accordance with the type listed in primaryType,
defined in types.
- `domain` will be shown above the message.
Its structure has to be in accordance with `StarkNetDomain`.

The predefined types that you can use :

- `felt` : for an integer on 251 bits.
- `felt*` : for an array of felt.
- `string` : for a shortString of 31 ASCII characters max.
- `selector` : for a name of a smart contract function.
- `merkletree` : for a Root of a Merkle tree, calculated with the provided data.

Specification details: [Signing transactions and off-chain messages](https://github.com/argentlabs/argent-x/discussions/14)

#### Message Hash Sample Code

For a complete `message_hash` example, refer to `python` code in [code-samples](https://github.com/tradeparadex/code-samples).

> Examples:

```json

	{
	  "paradex-signature-expiration": 1682364556,
	  "paradex-starknet-account": "0x129f3dc1b8962d8a87abc692424c78fda963ade0e1cd17bf3d1c26f8d41ee7a",
	  "paradex-starknet-signature": [
	    "1381323390094460587764867648394252677239485992175346764030313478865763678671",
	    "396490140510115262427678549757564216013606350105112805717359873954984880589"
	  ],
	  "paradex-timestamp": 1681759756
	}

```
*/
func (a *Client) Auth(params *AuthParams, opts ...ClientOption) (*AuthOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAuthParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "auth",
		Method:             "POST",
		PathPattern:        "/auth",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AuthReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AuthOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for auth: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
	Onboarding onboardings

	Onboarding verifies that the caller owns the StarkNet address and enters them

into the database. This call is idempotent.
*/
func (a *Client) Onboarding(params *OnboardingParams, opts ...ClientOption) (*OnboardingOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewOnboardingParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "onboarding",
		Method:             "POST",
		PathPattern:        "/onboarding",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &OnboardingReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*OnboardingOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for onboarding: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
